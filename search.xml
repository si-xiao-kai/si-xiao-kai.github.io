<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/12/02/hello-world/"/>
      <url>/2024/12/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>padding oracle攻击</title>
      <link href="/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/"/>
      <url>/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="一、CBC模式简介"><a href="#一、CBC模式简介" class="headerlink" title="一、CBC模式简介"></a>一、CBC模式简介</h1><p>CBC（Cipher Block Chaining，密码块链模式）是一种分组密码的加密模式，它通过将每个明文块与前一个密文块进行异或操作后再加密，以确保数据的安全性。</p><h2 id="1-1-CBC加密流程"><a href="#1-1-CBC加密流程" class="headerlink" title="1.1 CBC加密流程"></a>1.1 CBC加密流程</h2><p>在CBC模式中，首先对明文进行分组，每个明文块先与前一个密文块进行异或后，再进行加密。CBC模式下，每个密文块依赖于前面的所有的明文块。</p><p>涉及到的概念：</p><ol><li><strong>初始化向量（IV）</strong>：CBC模式使用一个初始化向量（IV），这是一个随机生成的值，与第一个明文块进行异或操作。IV的作用是为加密过程提供一个随机的起点，确保相同的明文块在不同的加密过程中产生不同的密文块。</li></ol><h3 id="1-1-1-加密流程"><a href="#1-1-1-加密流程" class="headerlink" title="1.1.1 加密流程"></a>1.1.1 加密流程</h3><p>其加密流程示意图如下：</p><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/%E6%88%AA%E5%B1%8F2024-11-29%2010.00.05.png" alt="CBC模式加密流程" style="zoom:50%;"><ul><li>将明文分为固定大小的块（通常是8字节或16字节）。</li><li>第一个明文块与IV进行异或操作。</li><li>异或后的结果通过加密算法（如AES）加密，生成第一个密文块。</li><li>每个后续的明文块都与前一个密文块进行异或操作，然后再加密，生成下一个密文块。</li></ul><p>密文分组3受到明文分组1、明文分组2、明文分组3的共同影响。</p><h3 id="1-1-2-解密流程"><a href="#1-1-2-解密流程" class="headerlink" title="1.1.2 解密流程"></a>1.1.2 解密流程</h3><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/%E6%88%AA%E5%B1%8F2024-11-29%2010.01.51.png" alt="CBC模式解密流程" style="zoom:50%;"><ul><li>将密文分为相同的块大小。</li><li>第一个密文块通过解密算法解密，然后与IV进行异或操作，恢复出第一个明文块。</li><li>每个后续的密文块都先解密，然后与前一个密文块进行异或操作，恢复出原始的明文块。</li></ul><p>与加密过程不同的是名文分组3仅受密文分组2和密文分组3的共同影响。</p><h3 id="1-1-3-填充（Padding）"><a href="#1-1-3-填充（Padding）" class="headerlink" title="1.1.3 填充（Padding）"></a>1.1.3 填充（Padding）</h3><p>分组带来一个问题，就是明文不可能恰好是block的整数倍，对于不能整除剩余的部分数据就涉及到填充操作。</p><p>在加密最后一个不完整的明文块时，需要进行填充以确保块的大小符合加密算法的要求。常见的填充方式有PKCS#5和OneAndZeroes。</p><h4 id="1）PKCS-5："><a href="#1）PKCS-5：" class="headerlink" title="1）PKCS#5："></a>1）PKCS#5：</h4><p>在最后一个block中将不足的Byte数作为Byte值进行填充，缺少n个Byte，就填充n个0x0n，例如最后一个分组（block）缺少3个byte，就填充3个0x03到结尾。在解密时会校验明文的填充是否满足该规则，如果是以N个0x0N结束，则意味着解密操作执行成功，否则解密操作失败。</p><h4 id="2）OneAndZeroes："><a href="#2）OneAndZeroes：" class="headerlink" title="2）OneAndZeroes："></a>2）OneAndZeroes：</h4><p>在最后一个Block中将不足的byte位数以 0x80开头后续全填0x00的方式进行填充，若最后一个Block缺少3byte，则填充：0x80 0x00 0x00。</p><h1 id="二、Padding-Oracle攻击原理"><a href="#二、Padding-Oracle攻击原理" class="headerlink" title="二、Padding Oracle攻击原理"></a>二、Padding Oracle攻击原理</h1><p>这种攻击方式在2011年的Pwnie Rewards中被评为“最具有价值的服务器漏洞”，因为它能够绕过对算法的直接破解，通过旁路攻击的方式被利用。</p><p>核心原理：明文分组和填充，同时应用程序对于填充异常的响应可以作为反馈。</p><h2 id="2-1-利用场景"><a href="#2-1-利用场景" class="headerlink" title="2.1 利用场景"></a>2.1 利用场景</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http://www.example.com/decrypt.jsp?data<span class="token operator">=</span>0000000000000000EFC2807233F9D7C097116BB33E813C5E<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当攻击者在篡改data值时会有以下不同的响应：</p><ul><li>如果data值没有被篡改，则解密成功，并且业务校验成功，响应200</li><li>如果data值被篡改，服务端无法完成解密，解密校验失败，则响应500</li><li>如果data值被篡改，但是服务端解密成功，但业务逻辑校验失败，则可能返回200或302等响应码,而不是响应500</li></ul><p>攻击者只需关注解密成功和解密失败的响应即可（第三种属于解密成功的响应），即可完成攻击。</p><h2 id="2-2-破解密文"><a href="#2-2-破解密文" class="headerlink" title="2.2 破解密文"></a>2.2 破解密文</h2><h3 id="2-2-1-核心思路"><a href="#2-2-1-核心思路" class="headerlink" title="2.2.1 核心思路"></a>2.2.1 核心思路</h3><p>攻击者通过修改密文并发送给服务器，观察服务器对不同密文的响应。如果密文的填充正确，服务器会返回一个成功的响应；如果填充不正确，服务器会返回一个错误响应。攻击者利用这种差异性来确定密文的正确填充，从而逐步解密密文或构造出任意明文的合法密文。</p><h3 id="2-2-2-攻击过程"><a href="#2-2-2-攻击过程" class="headerlink" title="2.2.2 攻击过程"></a>2.2.2 攻击过程</h3><p>假设有这样一个应用，请求如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http://www.example.com/decrypt.jsp?data<span class="token operator">=</span>7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即client给server提交的参数为<code>7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6</code> 才能请求正常的服务.</p><h4 id="1）内在加解密过程（不为攻击者所知晓）"><a href="#1）内在加解密过程（不为攻击者所知晓）" class="headerlink" title="1）内在加解密过程（不为攻击者所知晓）"></a>1）内在加解密过程（不为攻击者所知晓）</h4><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/%E6%88%AA%E5%B1%8F2024-11-29%2010.03.19.png" alt="IV+密文值" style="zoom:80%;"><p>IV添加在密文的前段，即最前面8个字节。</p><ul><li>加密过程</li></ul><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/%E6%88%AA%E5%B1%8F2024-11-28%2010.26.09.png" alt="加密过程" style="zoom:80%;"><ul><li>解密过程</li></ul><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/%E6%88%AA%E5%B1%8F2024-11-28%2010.27.56.png" alt="解密过程" style="zoom:80%;"><p>值得注意的是，解密之后的最后一个数据块，其结尾应该包含正确的填充序列，如果不满足，加解密程序会返回异常（500）。</p><h4 id="2）攻击者视角破解密文"><a href="#2）攻击者视角破解密文" class="headerlink" title="2）攻击者视角破解密文"></a>2）攻击者视角破解密文</h4><ul><li>IV值置空</li></ul><p>取第一个Block的密文，并将初始化向量置为0，即：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> F8 <span class="token number">51</span> D6 CC <span class="token number">68</span> FC <span class="token number">95</span> <span class="token number">37</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时的请求和响应：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Request: http://sampleapp/home.jsp?<span class="token environment constant">UID</span><span class="token operator">=</span>0000000000000000F851D6CC68FC9537Response: <span class="token number">500</span> - Internal Server Error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>回复500说明填充异常，原因是它的结尾未包含正确的填充字节：</p><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/%E6%88%AA%E5%B1%8F2024-11-28%2010.32.04.png" alt="0000000000000000F851D6CC68FC9537解密失败" style="zoom:80%;"><p>如上图所示，在解密之后，数据块的末尾并没有包含正确的填充序列，因此出现了异常。</p><ul><li>接下来尝试爆破，使得最后的填充序列满足<code>n个0xn</code>的条件</li></ul><p>我们将IV加1，并且发送同样密文</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Request: http://sampleapp/home.jsp?<span class="token environment constant">UID</span><span class="token operator">=</span>0000000000000001F851D6CC68FC9537Response: <span class="token number">500</span> - Internal Server Error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/%E6%88%AA%E5%B1%8F2024-11-28%2010.34.03.png" alt="0000000000000001F851D6CC68FC9537解密失败" style="zoom:80%;"><p>重复发送这样的请求，每次将IV的最后一个字节加一（直至<code>0xFF</code>），那么最终我们将会产生一个合法的单字节填充序列（<code>0x01</code>）</p><p>对于可能的256个值中，只有一个值会产生正确的填充字节<code>0x01</code>，遇上这个值的时候，会得到一个不同于其他255个请求的回复结果。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Request: http://sampleapp/home.jsp?<span class="token environment constant">UID</span><span class="token operator">=</span>000000000000003CF851D6CC68FC9537Response: <span class="token number">200</span> OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/%E6%88%AA%E5%B1%8F2024-11-28%2010.36.05.png" alt="000000000000003CF851D6CC68FC9537解密成功" style="zoom:80%;"><ul><li>推断出中间值（Intermediary Value）的最后一个字节（注意中间值攻击者不知道，他是攻击者攻击的目标）</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Intermediary Byte 异或 <span class="token number">0</span>×3C <span class="token operator">==</span> <span class="token number">0</span>×01, Intermediary Byte <span class="token operator">==</span> <span class="token number">0</span>×3C ^ <span class="token number">0</span>×01, Intermediary Byte <span class="token operator">==</span> <span class="token number">0</span>×3D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>重点：第一组密文解密的中间值是一直不变的，同样也是正确的，我们通过构造IV值，使得最后一位填充值满足0x01，符合padding规则，则意味着程序解密成功（当然解密的结果肯定不是原来的明文），通过循环测试的方法，猜解出中间值的最后一位，再利用同样的方式猜解前面的中间值，直到获取到完整的中间值。</p><ul><li>推断出中间值的倒数第二个字节。</li></ul><p>构造填充值为<code>0x02 0x02</code>的场景，即存在2个填充字节，填充值为<code>0x02</code>。</p><p>此时我们已经知道了中间值得最后一位为<code>0x3D</code>,计算出初始向量的最后一位：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0x3D xor 0x02 <span class="token operator">=</span> 0x3F<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即初始向量为<code>0000000000000003F</code></p><p>遍历倒数第二个字节从<code>0x00~0xFF</code>，直到响应成功.</p><p>猜解出中间值得后两个字节分别为 <code>0x26 0x3D</code></p><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/%E6%88%AA%E5%B1%8F2024-11-28%2010.45.22.png" alt="破解出中间值的倒数第二个字节" style="zoom:80%;"><ul><li>推断出整个中间值</li></ul><p>运用这种技巧，我们可以最终得到解密后的中间值，也就是当整个数据块的填充值都是<code>0x08</code></p><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/%E6%88%AA%E5%B1%8F2024-11-28%2010.46.30.png" alt="中间值完整推断" style="zoom:80%;"><ul><li>明文破解</li></ul><p>当第一组密文的中间值猜解成功后，我们将中间值和已知的IV做异或，则得到第一组密文的明文：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0x39 0x73 0x23 0x22 0x07 0x6A 0x26 0x3D  异或  0x7B 0x21 0x6A 0x63 0x49 0x51 0x17 0x0F<span class="token operator">=</span> BRIAN<span class="token punctuation">;</span><span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>续破解第二组密文，第二组密文的IV向量是第一组密文，按照上述的逻辑构造第一组密文，即可破解出第二组明文。</p><h3 id="2-2-3-思路总结"><a href="#2-2-3-思路总结" class="headerlink" title="2.2.3 思路总结"></a>2.2.3 思路总结</h3><ul><li>将IV最后一个字节设置为0x1，不断调整IV最后一个字节（0x01-0xff），爆破使得填充规则正确(7byte+0x01)，得到中间值的最后一个字节。</li><li>在得到最后一个字节的中间值后，将IV最后一个字节设置为0x02，计算IV的最后一个字节。</li><li>不断调整IV倒数第二个字节（0x01-0xff），爆破使得填充规则正确（6byte+0x02+0x02），得到倒数第二个字节的中间值。</li><li>依次类推获得整个中间值。</li><li>中间值和IV异或获得明文。</li></ul><h2 id="2-3伪造明文"><a href="#2-3伪造明文" class="headerlink" title="2.3伪造明文"></a>2.3伪造明文</h2><p>通过密文的破解过程，我们已经掌握了中间值（中间值同密文块是绑定的）和IV。</p><p>结合解密的流程，我们可以通过操纵IV来控制（密文块）解密得到的结果。</p><p>如果想要将密文中第一个数据块解密为“TEST”这个值，您可以计算出它所需要的IV值，只要将目标明文与中间值进行异或操作即可</p><p>只要将字符串”TEST”和4个<code>0x04</code>填充字节与中间值异或之后，便可以得到最终的IV，即<code>0×6D，0×36，0×70，0×76，0×03，0×6E，0×22，0×39</code></p><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/%E6%88%AA%E5%B1%8F2024-11-28%2010.52.22.png" alt="伪造明文示例" style="zoom:80%;"><p>如何生成长度超过一个数据块的明文，比如要生成”ENCRYPT TEST”</p><p>首先还是将文本拆成数据块，并设置填充字节</p><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/%E6%88%AA%E5%B1%8F2024-11-28%2010.54.01.png" alt="伪造大于一个块的明文长度" style="zoom:60%;"><p>通过类似的步骤我们可以知道生成TEST0x040x040x040x04的中间值(0xc3 0x60 0xed 0xc9 0x 6d 0xf9 0x90 0x32)和IV1(也就是BLOCK1对应的密文)。</p><p>接下来，我们需要弄明白中间值IV1在作为密文是如何解密的。</p><p>只要使用与之前破解过程相同的技巧就行了，我们把它作为密文传递给应用程序，并从全部为NULL的IV开始进行暴力破解。的到IV1对应的中间值IV1_IM。</p><p>通过IV1_IM可以构造BLOCK1的明文为ENCRYPT%20，然后计算得到初始IV值。 </p><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/padding-oracle-gong-ji/%E6%88%AA%E5%B1%8F2024-11-28%2011.06.12.png" style="zoom:80%;"><h1 id="三、exp"><a href="#三、exp" class="headerlink" title="三、exp"></a>三、exp</h1><h2 id="3-1-poa-py"><a href="#3-1-poa-py" class="headerlink" title="3.1 poa.py"></a>3.1 poa.py</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/env python</span><span class="token keyword">from</span> hexdump <span class="token keyword">import</span> hexdump<span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Cipher <span class="token keyword">import</span> AES<span class="token keyword">import</span> IPythonplain <span class="token operator">=</span> <span class="token string">b"Hello World! MTDP! RedTeam! 23333"</span><span class="token keyword">class</span> <span class="token class-name">POA</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    KEY <span class="token operator">=</span> <span class="token string">b"1234567890abcdef"</span>    IV <span class="token operator">=</span> <span class="token string">b"0102030405060708"</span>    <span class="token decorator annotation punctuation">@classmethod</span>    <span class="token keyword">def</span> <span class="token function">__pad</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> text<span class="token punctuation">:</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""PKCS7 padding"""</span>        text_length <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>        amount_to_pad <span class="token operator">=</span> AES<span class="token punctuation">.</span>block_size <span class="token operator">-</span> <span class="token punctuation">(</span>text_length <span class="token operator">%</span> AES<span class="token punctuation">.</span>block_size<span class="token punctuation">)</span>        <span class="token keyword">if</span> amount_to_pad <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            amount_to_pad <span class="token operator">=</span> AES<span class="token punctuation">.</span>block_size        pad <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span>amount_to_pad<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> text <span class="token operator">+</span> pad <span class="token operator">*</span> amount_to_pad    <span class="token decorator annotation punctuation">@classmethod</span>    <span class="token keyword">def</span> <span class="token function">__unpad</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> text<span class="token punctuation">:</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        pad <span class="token operator">=</span> text<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        _pad <span class="token operator">=</span> text<span class="token punctuation">[</span><span class="token operator">-</span>pad<span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> _pad<span class="token punctuation">:</span>            <span class="token keyword">if</span> pad <span class="token operator">!=</span> i<span class="token punctuation">:</span>                <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">"Error Padding! - %s"</span> <span class="token operator">%</span> _pad<span class="token punctuation">)</span>        <span class="token keyword">return</span> text<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span>pad<span class="token punctuation">]</span>    <span class="token decorator annotation punctuation">@classmethod</span>    <span class="token keyword">def</span> <span class="token function">encrypt</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> plain<span class="token punctuation">:</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        pad_plain <span class="token operator">=</span> cls<span class="token punctuation">.</span>__pad<span class="token punctuation">(</span>plain<span class="token punctuation">)</span>        aes <span class="token operator">=</span> AES<span class="token punctuation">.</span>new<span class="token punctuation">(</span>mode<span class="token operator">=</span>AES<span class="token punctuation">.</span>MODE_CBC<span class="token punctuation">,</span> key<span class="token operator">=</span>cls<span class="token punctuation">.</span>KEY<span class="token punctuation">,</span> iv<span class="token operator">=</span>cls<span class="token punctuation">.</span>IV<span class="token punctuation">)</span>        cipher <span class="token operator">=</span> aes<span class="token punctuation">.</span>encrypt<span class="token punctuation">(</span>pad_plain<span class="token punctuation">)</span>        hexdump<span class="token punctuation">(</span>cipher<span class="token punctuation">)</span>        <span class="token keyword">return</span> cipher    <span class="token decorator annotation punctuation">@classmethod</span>    <span class="token keyword">def</span> <span class="token function">decrypt</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> cipher<span class="token punctuation">:</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        aes <span class="token operator">=</span> AES<span class="token punctuation">.</span>new<span class="token punctuation">(</span>mode<span class="token operator">=</span>AES<span class="token punctuation">.</span>MODE_CBC<span class="token punctuation">,</span> key<span class="token operator">=</span>cls<span class="token punctuation">.</span>KEY<span class="token punctuation">,</span> iv<span class="token operator">=</span>cls<span class="token punctuation">.</span>IV<span class="token punctuation">)</span>        pad_plain <span class="token operator">=</span> aes<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>cipher<span class="token punctuation">)</span>        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>__unpad<span class="token punctuation">(</span>pad_plain<span class="token punctuation">)</span>    <span class="token decorator annotation punctuation">@classmethod</span>    <span class="token keyword">def</span> <span class="token function">decrypt_without_result</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> cipher<span class="token punctuation">:</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            cls<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>cipher<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>            <span class="token comment"># print(e)</span>            <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> POA<span class="token punctuation">.</span>encrypt<span class="token punctuation">(</span>plain<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    cipher <span class="token operator">=</span> test<span class="token punctuation">(</span><span class="token punctuation">)</span>    plain <span class="token operator">=</span> POA<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>cipher<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>plain<span class="token punctuation">)</span>    IPython<span class="token punctuation">.</span>embed<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-poa-attack-py"><a href="#3-2-poa-attack-py" class="headerlink" title="3.2 poa_attack.py"></a>3.2 poa_attack.py</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/env python3</span><span class="token keyword">import</span> pdb<span class="token keyword">from</span> poa <span class="token keyword">import</span> test<span class="token punctuation">,</span> POA<span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Cipher <span class="token keyword">import</span> AES<span class="token keyword">import</span> IPython<span class="token keyword">class</span> <span class="token class-name">PaddingOracleAttack</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> cipher<span class="token punctuation">,</span> iv<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>cipher <span class="token operator">=</span> cipher        <span class="token comment"># 把密文分割成列表，每个列表元素16字节</span>        self<span class="token punctuation">.</span>cipher_lst <span class="token operator">=</span> self<span class="token punctuation">.</span>split_block<span class="token punctuation">(</span>self<span class="token punctuation">.</span>cipher<span class="token punctuation">)</span>        <span class="token comment"># 解密的中间值</span>        self<span class="token punctuation">.</span>mid_lst <span class="token operator">=</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>brute_middle<span class="token punctuation">(</span>self<span class="token punctuation">.</span>cipher_lst<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment"># 存储计算出来的明文</span>        self<span class="token punctuation">.</span>plain_lst <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> self<span class="token punctuation">.</span>cipher_lst<span class="token punctuation">]</span>    <span class="token decorator annotation punctuation">@classmethod</span>    <span class="token keyword">def</span> <span class="token function">split_block</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> cipher<span class="token punctuation">)</span><span class="token punctuation">:</span>        cipher_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>cipher<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            cipher_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cipher<span class="token punctuation">[</span>i<span class="token punctuation">:</span> i <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> cipher_list    <span class="token keyword">def</span> <span class="token function">calc_new_tail</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tail<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">:</span>        new_tail <span class="token operator">=</span> <span class="token string">b""</span>        <span class="token keyword">for</span> t <span class="token keyword">in</span> tail<span class="token punctuation">:</span>            _tail <span class="token operator">=</span> t <span class="token operator">^</span> <span class="token punctuation">(</span>idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">^</span> idx            new_tail <span class="token operator">+=</span> _tail<span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">"big"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> new_tail    <span class="token keyword">def</span> <span class="token function">brute_middle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> cipher_line<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''暴力破解解密的中间值'''</span>        tail <span class="token operator">=</span> <span class="token string">b""</span>        mid_lst <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 从pad 为0x01开始 到 0x10</span>        <span class="token keyword">for</span> pad <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 计算新的pad尾部，因为每计算出来一个pad，再往前计算新的pad的时候，尾部的每一个值异或出来都要放大1位。</span>            tail <span class="token operator">=</span> self<span class="token punctuation">.</span>calc_new_tail<span class="token punctuation">(</span>tail<span class="token punctuation">,</span> pad<span class="token punctuation">)</span>            find_pad <span class="token operator">=</span> <span class="token boolean">False</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment"># 形成2个密文块</span>                cipher <span class="token operator">=</span> <span class="token string">b"\x00"</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">16</span> <span class="token operator">-</span> pad<span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">"big"</span><span class="token punctuation">)</span> <span class="token operator">+</span> tail <span class="token operator">+</span> cipher_line                <span class="token keyword">if</span> POA<span class="token punctuation">.</span>decrypt_without_result<span class="token punctuation">(</span>cipher<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token comment"># print("[!] Cipher - %s" % cipher)</span>                    find_pad <span class="token operator">=</span> <span class="token boolean">True</span>                    tail <span class="token operator">=</span> i<span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">"big"</span><span class="token punctuation">)</span> <span class="token operator">+</span> tail                    mid_chr <span class="token operator">=</span> i <span class="token operator">^</span> pad                    mid_lst<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> mid_chr<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token keyword">not</span> find_pad<span class="token punctuation">:</span>                <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">"Error not find pad!"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token builtin">bytes</span><span class="token punctuation">(</span>mid_lst<span class="token punctuation">)</span>    <span class="token decorator annotation punctuation">@classmethod</span>    <span class="token keyword">def</span> <span class="token function">__pad</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> text<span class="token punctuation">:</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""PKCS7 padding"""</span>        text_length <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>        amount_to_pad <span class="token operator">=</span> AES<span class="token punctuation">.</span>block_size <span class="token operator">-</span> <span class="token punctuation">(</span>text_length <span class="token operator">%</span> AES<span class="token punctuation">.</span>block_size<span class="token punctuation">)</span>        <span class="token keyword">if</span> amount_to_pad <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            amount_to_pad <span class="token operator">=</span> AES<span class="token punctuation">.</span>block_size        pad <span class="token operator">=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span>amount_to_pad<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> text <span class="token operator">+</span> pad <span class="token operator">*</span> amount_to_pad    <span class="token keyword">def</span> <span class="token function">fake</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> plain<span class="token punctuation">,</span> cipher<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> mid<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''伪造        :plain: 要伪造的明文        :last_cipher: 一个密文块        :last_mid:  密文块解密出来的中间值        '''</span>        pad_plain <span class="token operator">=</span> self<span class="token punctuation">.</span>__pad<span class="token punctuation">(</span>plain<span class="token punctuation">)</span>        plain_lst <span class="token operator">=</span> self<span class="token punctuation">.</span>split_block<span class="token punctuation">(</span>pad_plain<span class="token punctuation">)</span>        mid <span class="token operator">=</span> mid <span class="token keyword">if</span> mid <span class="token keyword">else</span> self<span class="token punctuation">.</span>mid_lst<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        cipher <span class="token operator">=</span> <span class="token punctuation">[</span>cipher <span class="token keyword">if</span> cipher <span class="token keyword">else</span> self<span class="token punctuation">.</span>cipher_lst<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token comment"># 从最后开始计算</span>        <span class="token keyword">for</span> plain <span class="token keyword">in</span> plain_lst<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            need_iv <span class="token operator">=</span> <span class="token string">b""</span>            <span class="token keyword">for</span> idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>plain<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                _m <span class="token operator">=</span> mid<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>                _p <span class="token operator">=</span> plain<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>                need_iv <span class="token operator">+=</span> <span class="token punctuation">(</span>_m <span class="token operator">^</span> _p<span class="token punctuation">)</span><span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">"big"</span><span class="token punctuation">)</span>            mid <span class="token operator">=</span> self<span class="token punctuation">.</span>brute_middle<span class="token punctuation">(</span>need_iv<span class="token punctuation">)</span>            cipher<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> need_iv<span class="token punctuation">)</span>        <span class="token keyword">return</span> cipher<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">b''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>cipher<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">decrypt</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''解密'''</span>        <span class="token comment"># 从最后开始计算</span>        self<span class="token punctuation">.</span>mid_lst <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> _idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>cipher_lst<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            line_idx <span class="token operator">=</span> _idx <span class="token operator">-</span> <span class="token number">1</span>            cipher_line <span class="token operator">=</span> self<span class="token punctuation">.</span>cipher_lst<span class="token punctuation">[</span>line_idx<span class="token punctuation">]</span>            <span class="token keyword">if</span> line_idx <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token comment"># 获取上一行密文数据，因为每一行的明文加密之前需要与上一行的密文异或</span>                p_cipher_line <span class="token operator">=</span> self<span class="token punctuation">.</span>cipher_lst<span class="token punctuation">[</span>line_idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment"># 如果是第一行，则其与IV异或</span>                p_cipher_line <span class="token operator">=</span> iv            _mid <span class="token operator">=</span> self<span class="token punctuation">.</span>brute_middle<span class="token punctuation">(</span>cipher_line<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>mid_lst<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> _mid<span class="token punctuation">)</span>            <span class="token keyword">for</span> idx<span class="token punctuation">,</span> _m <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>_mid<span class="token punctuation">)</span><span class="token punctuation">:</span>                plain_chr <span class="token operator">=</span> _m <span class="token operator">^</span> p_cipher_line<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>                self<span class="token punctuation">.</span>plain_lst<span class="token punctuation">[</span>line_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>plain_chr<span class="token punctuation">)</span>        plain <span class="token operator">=</span> <span class="token string">b""</span>        <span class="token keyword">for</span> p <span class="token keyword">in</span> self<span class="token punctuation">.</span>plain_lst<span class="token punctuation">:</span>            plain <span class="token operator">+=</span> <span class="token builtin">bytes</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>        <span class="token keyword">return</span> plain<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    cipher <span class="token operator">=</span> test<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment"># 获取密文</span>    iv <span class="token operator">=</span> POA<span class="token punctuation">.</span>IV         <span class="token comment"># 获取初始化向量</span>    poa_atck <span class="token operator">=</span> PaddingOracleAttack<span class="token punctuation">(</span>cipher<span class="token punctuation">,</span> iv<span class="token punctuation">)</span>    new_iv<span class="token punctuation">,</span> new_cipher <span class="token operator">=</span> poa_atck<span class="token punctuation">.</span>fake<span class="token punctuation">(</span><span class="token string">b"wo ai beijing tianan men!"</span><span class="token punctuation">)</span>    plain <span class="token operator">=</span> poa_atck<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span><span class="token punctuation">)</span>    IPython<span class="token punctuation">.</span>embed<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 密码学算法安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> padding oracle攻击 </tag>
            
            <tag> web安全中的密码学攻击 </tag>
            
            <tag> 密码学算法安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希长度扩展攻击</title>
      <link href="/2024/11/29/mi-ma-xue-suan-fa-an-quan/ha-xi-chang-du-kuo-zhan-gong-ji/"/>
      <url>/2024/11/29/mi-ma-xue-suan-fa-an-quan/ha-xi-chang-du-kuo-zhan-gong-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="一、MD5哈希算法"><a href="#一、MD5哈希算法" class="headerlink" title="一、MD5哈希算法"></a>一、MD5哈希算法</h1><h2 id="1-1-MD5简介"><a href="#1-1-MD5简介" class="headerlink" title="1.1 MD5简介"></a>1.1 MD5简介</h2><p>MD5（Message Digest Algorithm 5）是一种广泛使用的加密散列函数，它可以产生一个128位（16字节）的散列值（hash value），通常用一个32位的十六进制字符串表示，且具有不可逆性（即理论上从散列值无法推导出明文）。MD5由Ron Rivest在1991年设计，最初被用来作为一种安全的密码散列算法。它接收任意长度的输入，并产生一个固定长度的输出，这个输出被认为是输入数据的“指纹”。然而，由于后来发现MD5存在安全漏洞，它不再被推荐用于密码存储等安全敏感的应用。尽管如此，MD5仍然被用于一些非安全相关的场合，比如文件完整性检查。</p><h3 id="1-1-1-php-中md5函数的用法示例"><a href="#1-1-1-php-中md5函数的用法示例" class="headerlink" title="1.1.1 php 中md5函数的用法示例"></a>1.1.1 php 中md5函数的用法示例</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">echo</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"test string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">=</span> php5.6 index.php6f8db599de986fab7a21625b7916589c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-1-2-哈希函数与加密函数的区别"><a href="#1-1-2-哈希函数与加密函数的区别" class="headerlink" title="1.1.2 哈希函数与加密函数的区别"></a>1.1.2 哈希函数与加密函数的区别</h3><p>哈希将目标转换为具有相同长度的、不可逆的杂凑字符串；</p><p>加密则是将目标转化为不同长度的、可逆的密文，长度一般随明文增长而增加；</p><h3 id="1-1-3-常见的哈希算法介绍"><a href="#1-1-3-常见的哈希算法介绍" class="headerlink" title="1.1.3 常见的哈希算法介绍"></a>1.1.3 常见的哈希算法介绍</h3><p>当前最常用的哈希算法有<code>MD5</code>、<code>SHA-1</code>、<code>SHA-2（SHA-224、SHA-256、SHA-384，和SHA-512并称为SHA-2）</code>等。</p><h2 id="1-2-md5哈希算法流程详解"><a href="#1-2-md5哈希算法流程详解" class="headerlink" title="1.2 md5哈希算法流程详解"></a>1.2 md5哈希算法流程详解</h2><h3 id="1-2-0-步骤概览"><a href="#1-2-0-步骤概览" class="headerlink" title="1.2.0 步骤概览"></a>1.2.0 步骤概览</h3><p>MD5算法的详细流程可以概括为以下几个步骤：</p><p>1）明文填充</p><p>2）初始化变量</p><p>3）分块处理</p><p>4）循环压缩函数处理</p><p>5）更新寄存器</p><p>6）生成哈希值</p><p>具体的数据处理流程如图所示：</p><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/ha-xi-chang-du-kuo-zhan-gong-ji/%E6%88%AA%E5%B1%8F2024-11-29%2010.36.49.png" alt="算法数据处理流程概览" style="zoom:80%;"><h3 id="1-2-1-明文填充"><a href="#1-2-1-明文填充" class="headerlink" title="1.2.1 明文填充"></a>1.2.1 明文填充</h3><p>MD5以512bit为分块处理输入信息，每个分块又被分为16*32的子分组，最终输出为4*32的分组，即32为字符串。</p><ul><li>填充</li></ul><p>输入信息的长度(bit)对512求余不等于448时，使用OneAndZeroes对输入信息进行填充使得对512求余448。</p><p>假设对”abc”进行MD5计算，填充步骤：</p><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/ha-xi-chang-du-kuo-zhan-gong-ji/%E6%88%AA%E5%B1%8F2024-11-29%2010.32.09.png" alt="明文填充示意图" style="zoom:50%;"><ul><li>记录信息长度</li></ul><p>填充完成后，用64bit存储信息的长度，”abc”共有24bit，即0x18bit，记录的消息长度为：</p><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/ha-xi-chang-du-kuo-zhan-gong-ji/%E6%88%AA%E5%B1%8F2024-11-29%2010.33.18.png" alt="长度记录" style="zoom:50%;"><h3 id="1-2-2-初始化变量"><a href="#1-2-2-初始化变量" class="headerlink" title="1.2.2 初始化变量"></a>1.2.2 初始化变量</h3><p>MD5的哈希结果长度为128位，按每32位分成一组共4组。这4组结果是由4个初始值A、B、C、D经过不断演变得到。算法初始化四个32位的寄存器A、B、C、D，这些寄存器同时用于存储中间计算结果</p><p>MD5的官方实现中，A、B、C、D的初始值如下（16进制）：</p><p>A=0x01234567</p><p>B=0x89ABCDEF</p><p>C=0xFEDCBA98</p><p>D=0x76543210</p><h3 id="1-2-3-分块处理"><a href="#1-2-3-分块处理" class="headerlink" title="1.2.3 分块处理"></a>1.2.3 分块处理</h3><p>将填充后的数据按照512位（64字节）一块进行处理，每块包含16个32位字。</p><h3 id="1-2-4-循环压缩函数处理"><a href="#1-2-4-循环压缩函数处理" class="headerlink" title="1.2.4 循环压缩函数处理"></a>1.2.4 循环压缩函数处理</h3><p>对每个512位的数据块进行四轮循环压缩函数处理，每轮处理包括四个步骤：F函数、G函数、H函数和I函数。这些非线性函数在循环压缩函数处理中起着重要作用。</p><p>主要流程是以512位的分块为单位，每一分块经过4轮循环，每轮循环16次迭代，输出128位的结果，存放在缓冲区中，作为下一轮循环缓冲区的输入。</p><p>4轮循环的逻辑如图所示：</p><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/ha-xi-chang-du-kuo-zhan-gong-ji/%E6%88%AA%E5%B1%8F2024-11-29%2010.42.19.png" alt="512bit的数据处理流程" style="zoom:50%;"><p>从缓冲区输入128位，从消息分组输入512位，输出结果128位，要注意结果是由循环的结果加上缓冲区的值得到的(加法为模$2^32$加法)。A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由原文长度决定。假设处理后的原文长度是M，主循环次数 = M / 512，每个主循环中包含 （512/32） * 4 = 64 次子循环。上面这张图所表达的是单次子循环的流程。</p><p>每轮循环中单次迭代的逻辑如图所示：</p><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/ha-xi-chang-du-kuo-zhan-gong-ji/%E6%88%AA%E5%B1%8F2024-11-29%2010.59.48.png" alt="单轮循环中的单次迭代逻辑" style="zoom:50%;"><p>每轮循环迭代运算的逻辑：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>对A迭代：a <span class="token operator">&lt;</span>—— <span class="token number">6</span>+<span class="token punctuation">((</span>a+g<span class="token punctuation">(</span>b,c,d<span class="token punctuation">)</span>+X<span class="token punctuation">[</span>k<span class="token punctuation">]</span>+T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;&lt;</span>s<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>缓冲区（A,B,C,D<span class="token punctuation">)</span>作循环轮换：<span class="token punctuation">(</span>B,C,D,A<span class="token punctuation">)</span> <span class="token operator">&lt;</span>——<span class="token punctuation">(</span>A,B,C,D<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>a，b，c，d是缓冲区的当前值</li><li>g是4个轮函数之一，输入输出都是<code>32bit</code>，进行不同的逻辑运算</li><li><code>&lt;&lt;&lt;s</code>（CLS（s））是指把<code>bit32</code>循环左移<code>s</code>位，<code>s</code>可查表得到</li><li><code>X[k]</code>是当前处理消息分组的第<code>k</code>个<code>32bit</code>（一共512/32=16个字），在每一轮循环中都由不同的公式计算出来</li><li><code>T[i]</code>通过查表得到，32bit字</li><li>所有的加法都是模$2^32$加法</li></ul><p>4个轮函数逻辑如图所示：</p><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/ha-xi-chang-du-kuo-zhan-gong-ji/%E6%88%AA%E5%B1%8F2024-11-29%2011.05.00.png" alt="4个轮函数" style="zoom:50%;"><p>每轮循环中<code>X[k]</code>所取的<code>k</code>的计算方法为：</p><p>取<code>j</code>为当前迭代轮次</p><ol><li>第一轮循环：<code>k = j</code></li><li>第二轮循环：<code>k = (1 + 5 * j) % 16</code></li><li>第三轮循环：<code>k = (5 + 3 * j) % 16</code></li><li>第四轮循环：<code>k = (7 * j) % 16</code></li></ol><h3 id="1-2-5-更新寄存器"><a href="#1-2-5-更新寄存器" class="headerlink" title="1.2.5 更新寄存器"></a>1.2.5 更新寄存器</h3><p>根据每轮的计算结果更新寄存器A、B、C、D的值。</p><h3 id="1-3-6-生成哈希值"><a href="#1-3-6-生成哈希值" class="headerlink" title="1.3.6 生成哈希值"></a>1.3.6 生成哈希值</h3><p>最后一轮得到的结果经过高低位互换后就是最终的结果。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">6f8db599de986fab7a21625b7916589c<span class="token assign-left variable">A</span><span class="token operator">=</span>0x99b58d6f<span class="token assign-left variable">B</span><span class="token operator">=</span>0xab6f98de<span class="token assign-left variable">C</span><span class="token operator">=</span>0x5b62217a<span class="token assign-left variable">D</span><span class="token operator">=</span>0x9c581679<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>A B C D 分别按字节反转后拼接构成最后的哈希值。</p><h1 id="二、哈希长度扩展攻击原理"><a href="#二、哈希长度扩展攻击原理" class="headerlink" title="二、哈希长度扩展攻击原理"></a>二、哈希长度扩展攻击原理</h1><h2 id="2-1-攻击场景"><a href="#2-1-攻击场景" class="headerlink" title="2.1 攻击场景"></a>2.1 攻击场景</h2><h3 id="2-1-1-攻击场景1-文件下载权限验证"><a href="#2-1-1-攻击场景1-文件下载权限验证" class="headerlink" title="2.1.1 攻击场景1-文件下载权限验证"></a>2.1.1 攻击场景1-文件下载权限验证</h3><p>Message Authentication Codes (MACs)是用于验证信息真实性的算法。最简单的MAC算法是这样的：服务器把key和message连接到一起，然后用摘要算法如<code>MD5</code>或<code>SHA1</code>取出摘要。</p><p>例如有一个网站，在用户下载文件之前需验证下载权限。</p><p>这个网站会用如下的算法产生一个关于文件名的MAC：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">def Create_MAC<span class="token punctuation">(</span>key, filename<span class="token punctuation">)</span>   <span class="token builtin class-name">return</span> Digest::MD5.hexdigest<span class="token punctuation">(</span>key + filename<span class="token punctuation">)</span>end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>key对于攻击者来说是未知的。</p><p>用户请求下载test.pdf文件时提交如下请求：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http://www.example.com/download?file<span class="token operator">=</span>test.pdf<span class="token operator">&amp;</span><span class="token assign-left variable">mac</span><span class="token operator">=</span>ca21cf672b66a5ee6fa7fc7c1c314ff3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当用户发起请求要下载一个文件时，会执行下面这个函数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">def verify_mac<span class="token punctuation">(</span>key, filename, userMAC<span class="token punctuation">)</span>    validMAC <span class="token operator">=</span> create_MAC<span class="token punctuation">(</span>key, filename<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>validMAC <span class="token operator">==</span> userMAC<span class="token punctuation">)</span> <span class="token keyword">do</span>        initiateDownload<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">else</span>        displayError<span class="token punctuation">(</span><span class="token punctuation">)</span>    endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务端根据key和用户提交的文件名生成一个哈希值，跟用户提交的哈希值做比对，比对成功才会允许下载文件，这种情况下要求文件名和用户提供的mac值都是合法的。</p><p>本意是通过key的保密性来验证身份，因为正常情况下只有服务端和合法客户端才掌握key。</p><p>这样，只有当用户没有擅自更改文件名时服务器才会执行<code>initiateDownload()</code>开始下载。</p><p>但是这种生成MAC的方式，会给攻击者在文件名后添加自定义的字符串留下隐患。 </p><p>这种方法就是哈希长度拓展攻击。</p><p>攻击结果：不知道key、不知道合法文件名，但是能通过验证。</p><h3 id="2-1-2-攻击场景2"><a href="#2-1-2-攻击场景2" class="headerlink" title="2.1.2 攻击场景2"></a>2.1.2 攻击场景2</h3><p>在一道web题目中遇到了以下判断: <code>if ($COOKIE["md5hash"] === md5($secret . $input))</code></p><p>在该题目中我们可以掌握的参数有<code>md5hash</code>、<code>input</code>的值，<code>secret</code>的md5值和长度，我们需要想办法让这个判断通过。</p><p>难点在于：不知道$secret的情况下，传递一个哈希值和input，使得哈希值===md5($secret.$input)。</p><h2 id="2-2-哈希长度扩展攻击简介"><a href="#2-2-哈希长度扩展攻击简介" class="headerlink" title="2.2 哈希长度扩展攻击简介"></a>2.2 哈希长度扩展攻击简介</h2><p>哈希长度扩展攻击（Hash Length Extension Attacks）是一种针对某些加密散列函数的攻击手段，特别适用于那些基于Merkle–Damgård结构的算法，如MD5和SHA-1。这类攻击的核心在于，如果你知道一个消息（message）和密钥（key）的组合的哈希值，即使不知道密钥的具体值，只要知道密钥的长度，你就能在这个消息后面添加额外的信息，并计算出新的哈希值。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">md5<span class="token punctuation">(</span>xxxxx+<span class="token string">"plainText"</span><span class="token punctuation">)</span><span class="token operator">=</span>cdf1ea<span class="token punctuation">..</span>md5<span class="token punctuation">(</span>xxxxx+<span class="token string">"plainText"</span>+<span class="token string">"abcdfafa"</span><span class="token punctuation">)</span><span class="token operator">=</span>ade24242<span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>攻击条件：</p><ol><li>﻿﻿消息可控已知</li><li>﻿﻿密钥长度已知</li><li>﻿﻿﻿使用MD5加密且结果可知</li></ol><h2 id="2-3-攻击步骤"><a href="#2-3-攻击步骤" class="headerlink" title="2.3 攻击步骤"></a>2.3 攻击步骤</h2><h3 id="2-3-1-以某CTF赛题为例子"><a href="#2-3-1-以某CTF赛题为例子" class="headerlink" title="2.3.1 以某CTF赛题为例子"></a>2.3.1 以某CTF赛题为例子</h3><ul><li>代码如下：</li></ul><img src="/2024/11/29/mi-ma-xue-suan-fa-an-quan/ha-xi-chang-du-kuo-zhan-gong-ji/%E6%88%AA%E5%B1%8F2024-11-29%2014.21.21.png" alt="CTF赛题实例" style="zoom:50%;"><h3 id="2-3-2-条件分析"><a href="#2-3-2-条件分析" class="headerlink" title="2.3.2 条件分析"></a>2.3.2 条件分析</h3><p>从代码中已知<code>$this-&gt;sess=md5($this-&gt;token.$this-&gt;username)</code>，在不传递任何参数的情况下，<code>$sess</code>为token（20个未知字符）与”admin”组成的字符串的md5值，并且会在cookie中返回。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$username</span><span class="token operator">=</span><span class="token variable">$_COOKIE</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$sess</span><span class="token operator">=</span><span class="token variable">$_COOKIE</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'session'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从上面的代码可知，$sess和$username的值是用户提交的。</p><p>获取flag的条件是：提交一个伪造的非”admin”的username，并且提交该username与token拼接之后的md5值（也就是$sess），但是由于toekn不为我们所知晓，我们也无从计算出正确的md5值。</p><p>我们目前掌握的信息：</p><p>1）????????????????????admin 的哈希值 （?表示的内容为未知token），记为H1。</p><p>2）未知token的长度为20。</p><p>3）username和sess的值是可控的。</p><h3 id="2-3-3-核心要点"><a href="#2-3-3-核心要点" class="headerlink" title="2.3.3 核心要点"></a>2.3.3 核心要点</h3><p>巧妙利用md5哈希算法的分组运算机制。</p><p>将H1当作某个明文（这个明文我们需要伪造）中的第一个数据块（512bit）的散列值。根据md5算法以每512bit为数据块计算散列值的原理，当计算第二个数据块的散列值时，会以H1作为ABCD寄存器的缓存值。</p><p>我们如果能把字符串扩展到512bit以上，并保证第一段的md5运算结果不改变，那么我们在不知道第一段的加密内容的情况下仍然能够求得整体的md5值。此所谓”扩展”的含义。</p><h3 id="2-3-4-攻击实施"><a href="#2-3-4-攻击实施" class="headerlink" title="2.3.4 攻击实施"></a>2.3.4 攻击实施</h3><h4 id="1）模仿md5算法的填充"><a href="#1）模仿md5算法的填充" class="headerlink" title="1）模仿md5算法的填充"></a>1）模仿md5算法的填充</h4><p>所以我们首先要做的就是”模仿”md5算法的补位方式来进行补位。</p><p>????????????????????admin的长度=20+5=25个byte25*8=200bit</p><p>表示成16进制即为：0xC8=12*16+8=200</p><p>所以填充的结果如下（称为M1）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">【????????????????????admin】【8000000<span class="token punctuation">..</span><span class="token punctuation">..</span>000000】【c800000000000000】<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【（????????????????????admin）】为消息内容。</p><p>【8000000….000000】为填充值。</p><p>【c800000000000000】为长度填充。</p><p>如此一来，M1经过md5算法计算的结果，跟md5（????????????????????admin）计算的结果是一致的。我们知识作了md5算法本身就该做的事情。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">md5<span class="token punctuation">(</span>M1<span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">=</span>md5<span class="token punctuation">(</span>????????????????????admin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如前文所述，实际上在本实例中上述值我们是知道的，eg:ae8b63d93b14eadd1adb347c9e26595a（H1）</p><h4 id="2）将已知的H1值作为作为ABCD寄存器的缓存值"><a href="#2）将已知的H1值作为作为ABCD寄存器的缓存值" class="headerlink" title="2）将已知的H1值作为作为ABCD寄存器的缓存值"></a>2）将已知的H1值作为作为ABCD寄存器的缓存值</h4><p>将<code>ae8b63d93b14eadd1adb347c9e26595a</code>分成8字节唯一组的四组，ae8b63d9,3b14eadd,1adb347c,9e26595a</p><p>由于md5是小端存储，进行相应的调整：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">A</span><span class="token operator">=</span>0xd9638bae<span class="token assign-left variable">B</span><span class="token operator">=</span>0xddea143b<span class="token assign-left variable">C</span><span class="token operator">=</span>0x7c34db1a<span class="token assign-left variable">D</span><span class="token operator">=</span>0x5a59269e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3）拼接第二段内容"><a href="#3）拼接第二段内容" class="headerlink" title="3）拼接第二段内容"></a>3）拼接第二段内容</h4><p>M1+fakeadmin</p><p>将我们求出来的ABCD序列作为初始序列，利用md5算法对<code>fakeadmin</code>这个字符串进行md5加密。得到md5值：</p><p>比如是：bdbe1c6fb9d921e4ba3d9d4072b702f7（H2）</p><p>这个H2===md5(M1+fakeadmin)</p><h3 id="2-3-5-修改cookie获取flag"><a href="#2-3-5-修改cookie获取flag" class="headerlink" title="2.3.5 修改cookie获取flag"></a>2.3.5 修改cookie获取flag</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">username</span><span class="token operator">=</span>M1+fakeadmin<span class="token assign-left variable">session</span><span class="token operator">=</span>bdbe1c6fb9d921e4ba3d9d4072b702f7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="三、攻击工具"><a href="#三、攻击工具" class="headerlink" title="三、攻击工具"></a>三、攻击工具</h1><p><a href="https://github.com/iagox86/hash_extender">https://github.com/iagox86/hash_extender</a> 【hash_extender】</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-d</span> 被扩展的明文<span class="token parameter variable">-a</span> 附加的到原来hash的padding<span class="token parameter variable">-l</span> 盐的长度<span class="token parameter variable">-f</span> 加密方式<span class="token parameter variable">-s</span> 带盐加密的hash值--out-data-format 输出格式<span class="token parameter variable">--quiet</span> 仅输出必要的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> 密码学算法安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学算法安全 </tag>
            
            <tag> 哈希长度扩展攻击 </tag>
            
            <tag> md5哈希长度扩展攻击 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
